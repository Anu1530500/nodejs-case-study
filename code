// ===== package.json =====
{
  "name": "ecom-evaluation-app",
  "version": "1.0.0",
  "description": "E-commerce application with analytics dashboard",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "migrate": "node scripts/runMigrations.js",
    "seed": "node scripts/populateTestData.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mysql2": "^3.6.0",
    "dotenv": "^16.3.1",
    "cors": "^2.8.5",
    "helmet": "^7.0.0",
    "express-rate-limit": "^6.8.1",
    "express-validator": "^7.0.1",
    "morgan": "^1.10.0",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}

// ===== .env =====
# Database Configuration
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=your_password
DB_NAME=ecom_evaluation
DB_PORT=3306

# Server Configuration
PORT=3000
NODE_ENV=development

# JWT Secret (for future authentication)
JWT_SECRET=your_jwt_secret_key_here

// ===== server.js =====
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Security middleware
app.use(helmet());
app.use(cors());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use(limiter);

// Logging
app.use(morgan('combined'));

// Body parsing middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Routes
app.use('/api/products', require('./routes/products'));
app.use('/api/orders', require('./routes/orders'));
app.use('/api/dashboard', require('./routes/dashboard'));
app.use('/api/visitors', require('./routes/visitors'));

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date().toISOString() });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    error: 'Something went wrong!',
    message: process.env.NODE_ENV === 'development' ? err.message : 'Internal server error'
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

app.listen(PORT, () => {
  console.log(`🚀 E-commerce server running on port ${PORT}`);
  console.log(`📊 Dashboard API: http://localhost:${PORT}/api/dashboard`);
});

module.exports = app;

// ===== config/database.js =====
const mysql = require('mysql2/promise');

const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || '',
  database: process.env.DB_NAME || 'ecom_evaluation',
  port: process.env.DB_PORT || 3306,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
};

// Create connection pool
const pool = mysql.createPool(dbConfig);

// Test database connection
async function testConnection() {
  try {
    const connection = await pool.getConnection();
    console.log('✅ Database connected successfully');
    connection.release();
  } catch (error) {
    console.error('❌ Database connection failed:', error.message);
  }
}

testConnection();

module.exports = { pool, dbConfig };

// ===== controllers/dashboardController.js =====
const { pool } = require('../config/database');
const { validationResult } = require('express-validator');

class DashboardController {
  // Get product trends with bucket-based filtering
  async getProductTrends(req, res) {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          error: 'Validation failed',
          details: errors.array()
        });
      }

      const { 
        startDate, 
        endDate, 
        bucketSize = 'day',
        productId 
      } = req.query;

      let query;
      let queryParams = [startDate, endDate];

      // Build dynamic query based on bucket size
      switch (bucketSize) {
        case 'week':
          query = `
            SELECT 
              YEARWEEK(date, 1) as bucket_key,
              DATE_SUB(date, INTERVAL WEEKDAY(date) DAY) as startDate,
              DATE_ADD(DATE_SUB(date, INTERVAL WEEKDAY(date) DAY), INTERVAL 6 DAY) as endDate,
              SUM(views) as total_views,
              SUM(purchases) as total_purchases,
              SUM(revenue) as total_revenue,
              COUNT(DISTINCT product_id) as unique_products,
              AVG(conversion_rate) as avg_conversion_rate
            FROM product_trends 
            WHERE date BETWEEN ? AND ?
            ${productId ? 'AND product_id = ?' : ''}
            GROUP BY YEARWEEK(date, 1)
            ORDER BY bucket_key
          `;
          break;
          
        case 'month':
          query = `
            SELECT 
              DATE_FORMAT(date, '%Y-%m') as bucket_key,
              DATE_FORMAT(date, '%Y-%m-01') as startDate,
              LAST_DAY(date) as endDate,
              SUM(views) as total_views,
              SUM(purchases) as total_purchases,
              SUM(revenue) as total_revenue,
              COUNT(DISTINCT product_id) as unique_products,
              AVG(conversion_rate) as avg_conversion_rate
            FROM product_trends 
            WHERE date BETWEEN ? AND ?
            ${productId ? 'AND product_id = ?' : ''}
            GROUP BY DATE_FORMAT(date, '%Y-%m')
            ORDER BY bucket_key
          `;
          break;
          
        default: // day
          query = `
            SELECT 
              date as bucket_key,
              date as startDate,
              date as endDate,
              SUM(views) as total_views,
              SUM(purchases) as total_purchases,
              SUM(revenue) as total_revenue,
              COUNT(DISTINCT product_id) as unique_products,
              AVG(conversion_rate) as avg_conversion_rate
            FROM product_trends 
            WHERE date BETWEEN ? AND ?
            ${productId ? 'AND product_id = ?' : ''}
            GROUP BY date
            ORDER BY date
          `;
      }

      if (productId) {
        queryParams.push(parseInt(productId));
      }

      const [rows] = await pool.execute(query, queryParams);

      // Calculate additional metrics
      const totalRevenue = rows.reduce((sum, row) => sum + parseFloat(row.total_revenue || 0), 0);
      const totalViews = rows.reduce((sum, row) => sum + parseInt(row.total_views || 0), 0);
      const totalPurchases = rows.reduce((sum, row) => sum + parseInt(row.total_purchases || 0), 0);

      res.json({
        success: true,
        data: {
          bucketSize,
          totalBuckets: rows.length,
          summary: {
            totalRevenue: parseFloat(totalRevenue.toFixed(2)),
            totalViews,
            totalPurchases,
            overallConversionRate: totalViews > 0 ? parseFloat((totalPurchases / totalViews * 100).toFixed(2)) : 0
          },
          buckets: rows.map(row => ({
            ...row,
            total_revenue: parseFloat(row.total_revenue || 0),
            avg_conversion_rate: parseFloat((row.avg_conversion_rate || 0).toFixed(2))
          }))
        }
      });

    } catch (error) {
      console.error('Error fetching product trends:', error);
      res.status(500).json({
        error: 'Internal server error',
        message: error.message
      });
    }
  }

  // Get visitor analytics with bucket-based filtering
  async getVisitorAnalytics(req, res) {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          error: 'Validation failed',
          details: errors.array()
        });
      }

      const { 
        startDate, 
        endDate, 
        bucketSize = 'day'
      } = req.query;

      let query;
      let queryParams = [startDate, endDate];

      switch (bucketSize) {
        case 'week':
          query = `
            SELECT 
              YEARWEEK(date, 1) as bucket_key,
              DATE_SUB(date, INTERVAL WEEKDAY(date) DAY) as startDate,
              DATE_ADD(DATE_SUB(date, INTERVAL WEEKDAY(date) DAY), INTERVAL 6 DAY) as endDate,
              COUNT(*) as total_visits,
              COUNT(DISTINCT session_id) as unique_sessions,
              COUNT(DISTINCT ip_address) as unique_visitors,
              AVG(visit_duration) as avg_duration,
              SUM(actions_count) as total_actions,
              AVG(actions_count) as avg_actions_per_visit
            FROM visitor_logs 
            WHERE date BETWEEN ? AND ?
            GROUP BY YEARWEEK(date, 1)
            ORDER BY bucket_key
          `;
          break;
          
        case 'month':
          query = `
            SELECT 
              DATE_FORMAT(date, '%Y-%m') as bucket_key,
              DATE_FORMAT(date, '%Y-%m-01') as startDate,
              LAST_DAY(date) as endDate,
              COUNT(*) as total_visits,
              COUNT(DISTINCT session_id) as unique_sessions,
              COUNT(DISTINCT ip_address) as unique_visitors,
              AVG(visit_duration) as avg_duration,
              SUM(actions_count) as total_actions,
              AVG(actions_count) as avg_actions_per_visit
            FROM visitor_logs 
            WHERE date BETWEEN ? AND ?
            GROUP BY DATE_FORMAT(date, '%Y-%m')
            ORDER BY bucket_key
          `;
          break;
          
        default: // day
          query = `
            SELECT 
              date as bucket_key,
              date as startDate,
              date as endDate,
              COUNT(*) as total_visits,
              COUNT(DISTINCT session_id) as unique_sessions,
              COUNT(DISTINCT ip_address) as unique_visitors,
              AVG(visit_duration) as avg_duration,
              SUM(actions_count) as total_actions,
              AVG(actions_count) as avg_actions_per_visit
            FROM visitor_logs 
            WHERE date BETWEEN ? AND ?
            GROUP BY date
            ORDER BY date
          `;
      }

      const [rows] = await pool.execute(query, queryParams);

      // Calculate summary metrics
      const totalVisits = rows.reduce((sum, row) => sum + parseInt(row.total_visits || 0), 0);
      const totalUniqueVisitors = new Set();
      
      // Get total unique visitors across all buckets
      const [uniqueVisitorsQuery] = await pool.execute(
        'SELECT COUNT(DISTINCT ip_address) as total_unique FROM visitor_logs WHERE date BETWEEN ? AND ?',
        [startDate, endDate]
      );

      res.json({
        success: true,
        data: {
          bucketSize,
          totalBuckets: rows.length,
          summary: {
            totalVisits,
            totalUniqueVisitors: uniqueVisitorsQuery[0].total_unique,
            avgVisitDuration: rows.length > 0 ? 
              parseFloat((rows.reduce((sum, row) => sum + parseFloat(row.avg_duration || 0), 0) / rows.length).toFixed(2)) : 0
          },
          buckets: rows.map(row => ({
            ...row,
            avg_duration: parseFloat((row.avg_duration || 0).toFixed(2)),
            avg_actions_per_visit: parseFloat((row.avg_actions_per_visit || 0).toFixed(2))
          }))
        }
      });

    } catch (error) {
      console.error('Error fetching visitor analytics:', error);
      res.status(500).json({
        error: 'Internal server error',
        message: error.message
      });
    }
  }

  // Get top products by revenue
  async getTopProducts(req, res) {
    try {
      const { startDate, endDate, limit = 10 } = req.query;

      const query = `
        SELECT 
          pt.product_id,
          p.name as product_name,
          p.price,
          SUM(pt.views) as total_views,
          SUM(pt.purchases) as total_purchases,
          SUM(pt.revenue) as total_revenue,
          AVG(pt.conversion_rate) as avg_conversion_rate
        FROM product_trends pt
        LEFT JOIN products p ON pt.product_id = p.id
        WHERE pt.date BETWEEN ? AND ?
        GROUP BY pt.product_id, p.name, p.price
        ORDER BY total_revenue DESC
        LIMIT ?
      `;

      const [rows] = await pool.execute(query, [startDate, endDate, parseInt(limit)]);

      res.json({
        success: true,
        data: {
          topProducts: rows.map(row => ({
            ...row,
            total_revenue: parseFloat(row.total_revenue || 0),
            avg_conversion_rate: parseFloat((row.avg_conversion_rate || 0).toFixed(2)),
            price: parseFloat(row.price || 0)
          }))
        }
      });

    } catch (error) {
      console.error('Error fetching top products:', error);
      res.status(500).json({
        error: 'Internal server error',
        message: error.message
      });
    }
  }
}

module.exports = new DashboardController();

// ===== controllers/productController.js =====
const { pool } = require('../config/database');
const { validationResult } = require('express-validator');

class ProductController {
  async getAllProducts(req, res) {
    try {
      const { page = 1, limit = 20, category, search, sortBy = 'created_at', order = 'DESC' } = req.query;
      const offset = (parseInt(page) - 1) * parseInt(limit);

      let whereClause = 'WHERE 1=1';
      let queryParams = [];

      if (category) {
        whereClause += ' AND category = ?';
        queryParams.push(category);
      }

      if (search) {
        whereClause += ' AND (name LIKE ? OR description LIKE ?)';
        queryParams.push(`%${search}%`, `%${search}%`);
      }

      const query = `
        SELECT * FROM products 
        ${whereClause}
        ORDER BY ${sortBy} ${order}
        LIMIT ? OFFSET ?
      `;

      queryParams.push(parseInt(limit), offset);

      const [products] = await pool.execute(query, queryParams);
      const [countResult] = await pool.execute(`SELECT COUNT(*) as total FROM products ${whereClause}`, queryParams.slice(0, -2));

      res.json({
        success: true,
        data: {
          products,
          pagination: {
            page: parseInt(page),
            limit: parseInt(limit),
            total: countResult[0].total,
            pages: Math.ceil(countResult[0].total / parseInt(limit))
          }
        }
      });

    } catch (error) {
      console.error('Error fetching products:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  async getProductById(req, res) {
    try {
      const { id } = req.params;
      const [products] = await pool.execute('SELECT * FROM products WHERE id = ?', [id]);

      if (products.length === 0) {
        return res.status(404).json({ error: 'Product not found' });
      }

      res.json({
        success: true,
        data: { product: products[0] }
      });

    } catch (error) {
      console.error('Error fetching product:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  async createProduct(req, res) {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          error: 'Validation failed',
          details: errors.array()
        });
      }

      const { name, description, price, category, stock_quantity, image_url } = req.body;

      const query = `
        INSERT INTO products (name, description, price, category, stock_quantity, image_url)
        VALUES (?, ?, ?, ?, ?, ?)
      `;

      const [result] = await pool.execute(query, [name, description, price, category, stock_quantity, image_url]);

      res.status(201).json({
        success: true,
        data: {
          id: result.insertId,
          message: 'Product created successfully'
        }
      });

    } catch (error) {
      console.error('Error creating product:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }
}

module.exports = new ProductController();

// ===== routes/dashboard.js =====
const express = require('express');
const router = express.Router();
const { query } = require('express-validator');
const dashboardController = require('../controllers/dashboardController');

// Validation middleware for date parameters
const validateDateRange = [
  query('startDate')
    .isISO8601()
    .withMessage('startDate must be a valid date in YYYY-MM-DD format'),
  query('endDate')
    .isISO8601()
    .withMessage('endDate must be a valid date in YYYY-MM-DD format'),
  query('bucketSize')
    .optional()
    .isIn(['day', 'week', 'month'])
    .withMessage('bucketSize must be one of: day, week, month'),
  query('productId')
    .optional()
    .isInt({ min: 1 })
    .withMessage('productId must be a positive integer')
];

// Product trends endpoint
router.get('/products', validateDateRange, dashboardController.getProductTrends);

// Visitor analytics endpoint  
router.get('/visitors', validateDateRange.slice(0, 3), dashboardController.getVisitorAnalytics);

// Top products endpoint
router.get('/top-products', [
  query('startDate').isISO8601().withMessage('startDate must be a valid date'),
  query('endDate').isISO8601().withMessage('endDate must be a valid date'),
  query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('limit must be between 1 and 100')
], dashboardController.getTopProducts);

module.exports = router;

// ===== routes/products.js =====
const express = require('express');
const router = express.Router();
const { body } = require('express-validator');
const productController = require('../controllers/productController');

// Validation middleware for product creation
const validateProduct = [
  body('name')
    .trim()
    .isLength({ min: 1, max: 255 })
    .withMessage('Name is required and must be less than 255 characters'),
  body('description')
    .optional()
    .trim()
    .isLength({ max: 1000 })
    .withMessage('Description must be less than 1000 characters'),
  body('price')
    .isFloat({ min: 0 })
    .withMessage('Price must be a positive number'),
  body('category')
    .trim()
    .isLength({ min: 1, max: 100 })
    .withMessage('Category is required and must be less than 100 characters'),
  body('stock_quantity')
    .isInt({ min: 0 })
    .withMessage('Stock quantity must be a non-negative integer'),
  body('image_url')
    .optional()
    .isURL()
    .withMessage('Image URL must be a valid URL')
];

// Routes
router.get('/', productController.getAllProducts);
router.get('/:id', productController.getProductById);
router.post('/', validateProduct, productController.createProduct);

module.exports = router;

// ===== routes/visitors.js =====
const express = require('express');
const router = express.Router();
const { pool } = require('../config/database');
const { v4: uuidv4 } = require('uuid');

// Middleware to track visitor
async function trackVisitor(req, res, next) {
  try {
    const sessionId = req.headers['x-session-id'] || uuidv4();
    const ipAddress = req.ip || req.connection.remoteAddress;
    const userAgent = req.get('User-Agent') || 'Unknown';
    const pageUrl = req.originalUrl;
    const referrer = req.get('Referrer') || null;

    const query = `
      INSERT INTO visitor_logs 
      (session_id, ip_address, user_agent, page_url, referrer, visit_duration, actions_count, timestamp, date)
      VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), CURDATE())
    `;

    await pool.execute(query, [
      sessionId,
      ipAddress,
      userAgent,
      pageUrl,
      referrer,
      0, // Initial duration
      1   // Initial action count
    ]);

    req.sessionId = sessionId;
    next();
  } catch (error) {
    console.error('Error tracking visitor:', error);
    next(); // Continue even if tracking fails
  }
}

// Track page visit
router.post('/track', trackVisitor, (req, res) => {
  res.json({
    success: true,
    sessionId: req.sessionId,
    message: 'Visit tracked successfully'
  });
});

module.exports = router;

// ===== routes/orders.js =====
const express = require('express');
const router = express.Router();
const { pool } = require('../config/database');
const { body, validationResult } = require('express-validator');

const validateOrder = [
  body('items')
    .isArray({ min: 1 })
    .withMessage('Items array is required and must not be empty'),
  body('items.*.product_id')
    .isInt({ min: 1 })
    .withMessage('Product ID must be a positive integer'),
  body('items.*.quantity')
    .isInt({ min: 1 })
    .withMessage('Quantity must be a positive integer'),
  body('total_amount')
    .isFloat({ min: 0 })
    .withMessage('Total amount must be a positive number')
];

// Create new order
router.post('/', validateOrder, async (req, res) => {
  const connection = await pool.getConnection();
  
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation failed',
        details: errors.array()
      });
    }

    await connection.beginTransaction();

    const { items, total_amount, customer_email } = req.body;

    // Create order
    const [orderResult] = await connection.execute(
      'INSERT INTO orders (customer_email, total_amount, status) VALUES (?, ?, ?)',
      [customer_email, total_amount, 'pending']
    );

    const orderId = orderResult.insertId;

    // Create order items and update product trends
    for (const item of items) {
      await connection.execute(
        'INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (?, ?, ?, ?)',
        [orderId, item.product_id, item.quantity, item.price]
      );

      // Update product trends
      await connection.execute(`
        INSERT INTO product_trends (product_id, views, purchases, revenue, date)
        VALUES (?, 0, ?, ?, CURDATE())
        ON DUPLICATE KEY UPDATE
        purchases = purchases + VALUES(purchases),
        revenue = revenue + VALUES(revenue)
      `, [item.product_id, item.quantity, item.price * item.quantity]);
    }

    await connection.commit();

    res.status(201).json({
      success: true,
      data: {
        orderId,
        message: 'Order created successfully'
      }
    });

  } catch (error) {
    await connection.rollback();
    console.error('Error creating order:', error);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    connection.release();
  }
});

module.exports = router;

// ===== scripts/runMigrations.js =====
const { pool } = require('../config/database');

const migrations = [
  {
    name: '001_create_products_table',
    sql: `
      CREATE TABLE IF NOT EXISTS products (
        id INT AUTO_INCREMENT PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        description TEXT,
        price DECIMAL(10,2) NOT NULL,
        category VARCHAR(100) NOT NULL,
        stock_quantity INT DEFAULT 0,
        image_url VARCHAR(500),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX idx_category (category),
        INDEX idx_price (price),
        INDEX idx_created_at (created_at)
      );
    `
  },
  {
    name: '002_create_product_trends_table',
    sql: `
      CREATE TABLE IF NOT EXISTS product_trends (
        id INT AUTO_INCREMENT PRIMARY KEY,
        product_id INT NOT NULL,
        views INT DEFAULT 0,
        purchases INT DEFAULT 0,
        revenue DECIMAL(10,2) DEFAULT 0.00,
        conversion_rate DECIMAL(5,2) DEFAULT 0.00,
        date DATE NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        UNIQUE KEY unique_product_date (product_id, date),
        INDEX idx_product_date (product_id, date),
        INDEX idx_date (date),
        FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE
      );
    `
  },
  {
    name: '003_create_visitor_logs_table',
    sql: `
      CREATE TABLE IF NOT EXISTS visitor_logs (
        id INT AUTO_INCREMENT PRIMARY KEY,
        session_id VARCHAR(255) NOT NULL,
        ip_address VARCHAR(45),
        user_agent TEXT,
        page_url VARCHAR(500),
        referrer VARCHAR(500),
        visit_duration INT DEFAULT 0,
        actions_count INT DEFAULT 0,
        timestamp DATETIME NOT NULL,
        date DATE NOT NULL,
        INDEX idx_session (session_id),
        INDEX idx_date (date),
        INDEX idx_timestamp (timestamp),
        INDEX idx_ip_date (ip_address, date)
      );
    `
  },
  {
    name: '004_create_orders_table',
    sql: `
      CREATE TABLE IF NOT EXISTS orders (
        id INT AUTO_INCREMENT PRIMARY KEY,
        customer_email VARCHAR(255),
        total_amount DECIMAL(10,2) NOT NULL,
        status ENUM('pending', 'confirmed', 'shipped', 'delivered', 'cancelled') DEFAULT 'pending',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX idx_status (status),
        INDEX idx_created_at (created_at)
      );
    `
  },
  {
    name: '005_create_order_items_table',
    sql: `
      CREATE TABLE IF NOT EXISTS order_items (
        id INT AUTO_INCREMENT PRIMARY KEY,
        order_id INT NOT NULL,
        product_id INT NOT NULL,
        quantity INT NOT NULL,
        price DECIMAL(10,2) NOT NULL,
        FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE,
        FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE RESTRICT
      );
    `
  }
];

async function runMigrations() {
  try {
    console.log('🔄 Running database migrations...');

    for (const migration of migrations) {
      console.log(`📝 Running migration: ${migration.name}`);
      await pool.execute(migration.sql);
      console.log(`✅ Completed: ${migration.name}`);
    }

    console.log('🎉 All migrations completed successfully!');
  } catch (error) {
    console.error('❌ Migration failed:', error.message);
    process.exit(1);
  } finally {
    await pool.end();
  }
}

runMigrations();

// ===== scripts/populateTestData.js =====
const { pool } = require('../config/database');

// Sample products data
const sampleProducts = [
  { name: 'Wireless Headphones', description: 'High-quality wireless headphones with noise cancellation', price: 199.99, category: 'Electronics', stock_quantity: 50, image_url: 'https://example.com/headphones.jpg' },
  { name: 'Smart Watch', description: 'Fitness tracking smartwatch with heart rate monitor', price: 299.99, category: 'Electronics', stock_quantity: 30, image_url: 'https://example.com/watch.jpg' },
  { name: 'Coffee Maker', description: 'Programmable coffee maker with thermal carafe', price: 89.99, category: 'Appliances', stock_quantity: 25, image_url: 'https://example.com/coffee.jpg' },
  { name: 'Running Shoes', description: 'Lightweight running shoes for all terrains', price: 129.99, category: 'Sports', stock_quantity: 40, image_url: 'https://example.com/shoes.jpg' },
  { name: 'Yoga Mat', description: 'Non-slip yoga mat perfect for home workouts', price: 34.99, category: 'Sports', stock_quantity: 60, image_url: 'https://example.com/yoga.jpg' },
  { name: 'Bluetooth Speaker', description: 'Portable wireless speaker with premium sound quality', price: 79.99, category: 'Electronics', stock_quantity: 35, image_url: 'https://example.com/speaker.jpg' },
  { name: 'Desk Lamp', description: 'LED desk lamp with adjustable brightness', price: 45.99, category: 'Home', stock_quantity: 20, image_url: 'https://example.com/lamp.jpg' },
  { name: 'Backpack', description: 'Waterproof laptop backpack for travel', price: 69.99, category: 'Accessories', stock_quantity: 45, image_url: 'https://example.com/backpack.jpg' },
  { name: 'Water Bottle', description: 'Insulated stainless steel water bottle', price: 24.99, category: 'Sports', stock_quantity: 75, image_url: 'https://example.com/bottle.jpg' },
  { name: 'Phone Case', description: 'Protective phone case with card holder', price: 19.99, category: 'Accessories', stock_quantity: 100, image_url: 'https://example.com/case.jpg' }
];

async function populateProducts() {
  console.log('📦 Populating products...');
  
  for (const product of sampleProducts) {
    await pool.execute(
      `INSERT IGNORE INTO products (name, description, price, category, stock_quantity, image_url) 
       VALUES (?, ?, ?, ?, ?, ?)`,
      [product.name, product.description, product.price, product.category, product.stock_quantity, product.image_url]
    );
  }
  
  console.log(`✅ Added ${sampleProducts.length} products`);
}

async function populateProductTrends() {
  console.log('📊 Populating product trends...');
  
  // Get product IDs
  const [products] = await pool.execute('SELECT id FROM products');
  const productIds = products.map(p => p.id);
  
  // Generate data for last 60 days
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - 60);
  
  let totalRecords = 0;
  
  for (let i = 0; i < 60; i++) {
    const currentDate = new Date(startDate);
    currentDate.setDate(startDate.getDate() + i);
    const dateString = currentDate.toISOString().split('T')[0];
    
    for (const productId of productIds) {
      const views = Math.floor(Math.random() * 200) + 50; // 50-250 views
      const purchases = Math.floor(Math.random() * Math.min(views * 0.1, 20)) + 1; // 1-20 purchases
      const basePrice = 25 + Math.random() * 200; // $25-$225 base price
      const revenue = purchases * (basePrice + Math.random() * 50); // Add some price variation
      const conversionRate = (purchases / views) * 100;
      
      await pool.execute(
        `INSERT INTO product_trends (product_id, views, purchases, revenue, conversion_rate, date) 
         VALUES (?, ?, ?, ?, ?, ?)
         ON DUPLICATE KEY UPDATE
         views = VALUES(views),
         purchases = VALUES(purchases),
         revenue = VALUES(revenue),
         conversion_rate = VALUES(conversion_rate)`,
        [productId, views, purchases, revenue.toFixed(2), conversionRate.toFixed(2), dateString]
      );
      
      totalRecords++;
    }
  }
  
  console.log(`✅ Added ${totalRecords} product trend records`);
}

async function populateVisitorLogs() {
  console.log('👥 Populating visitor logs...');
  
  const pages = ['/products', '/products/1', '/products/2', '/cart', '/checkout', '/', '/about', '/contact'];
  const userAgents = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
    'Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15',
    'Mozilla/5.0 (Android 11; Mobile; rv:68.0) Gecko/68.0 Firefox/88.0'
  ];
  const referrers = [
    'https://google.com',
    'https://facebook.com',
    'https://twitter.com',
    'https://instagram.com',
    null // Direct traffic
  ];
  
  // Generate data for last 60 days
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - 60);
  
  let totalVisits = 0;
  
  for (let i = 0; i < 60; i++) {
    const currentDate = new Date(startDate);
    currentDate.setDate(startDate.getDate() + i);
    const dateString = currentDate.toISOString().split('T')[0];
    
    // Generate 100-500 visits per day
    const visitsPerDay = Math.floor(Math.random() * 400) + 100;
    
    for (let j = 0; j < visitsPerDay; j++) {
      const sessionId = `session_${currentDate.getTime()}_${j}_${Math.random().toString(36).substr(2, 9)}`;
      const ipAddress = `${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`;
      const userAgent = userAgents[Math.floor(Math.random() * userAgents.length)];
      const pageUrl = pages[Math.floor(Math.random() * pages.length)];
      const referrer = referrers[Math.floor(Math.random() * referrers.length)];
      const visitDuration = Math.floor(Math.random() * 1800) + 30; // 30 seconds to 30 minutes
      const actionsCount = Math.floor(Math.random() * 15) + 1; // 1-15 actions
      
      // Random time during the day
      const visitTime = new Date(currentDate);
      visitTime.setHours(Math.floor(Math.random() * 24));
      visitTime.setMinutes(Math.floor(Math.random() * 60));
      visitTime.setSeconds(Math.floor(Math.random() * 60));
      
      await pool.execute(
        `INSERT INTO visitor_logs 
         (session_id, ip_address, user_agent, page_url, referrer, visit_duration, actions_count, timestamp, date) 
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [sessionId, ipAddress, userAgent, pageUrl, referrer, visitDuration, actionsCount, visitTime, dateString]
      );
      
      totalVisits++;
    }
  }
  
  console.log(`✅ Added ${totalVisits} visitor log records`);
}

async function populateOrders() {
  console.log('🛒 Populating sample orders...');
  
  // Get product IDs and prices
  const [products] = await pool.execute('SELECT id, price FROM products');
  
  let totalOrders = 0;
  
  // Generate orders for last 30 days
  for (let i = 0; i < 30; i++) {
    const currentDate = new Date();
    currentDate.setDate(currentDate.getDate() - i);
    
    // 5-20 orders per day
    const ordersPerDay = Math.floor(Math.random() * 16) + 5;
    
    for (let j = 0; j < ordersPerDay; j++) {
      const customerEmail = `customer${totalOrders}@example.com`;
      
      // Random number of items (1-3)
      const itemCount = Math.floor(Math.random() * 3) + 1;
      const orderItems = [];
      let totalAmount = 0;
      
      for (let k = 0; k < itemCount; k++) {
        const product = products[Math.floor(Math.random() * products.length)];
        const quantity = Math.floor(Math.random() * 3) + 1;
        const price = parseFloat(product.price);
        
        orderItems.push({
          product_id: product.id,
          quantity,
          price: price
        });
        
        totalAmount += price * quantity;
      }
      
      // Create order
      const [orderResult] = await pool.execute(
        'INSERT INTO orders (customer_email, total_amount, status, created_at) VALUES (?, ?, ?, ?)',
        [customerEmail, totalAmount.toFixed(2), 'confirmed', currentDate]
      );
      
      const orderId = orderResult.insertId;
      
      // Create order items
      for (const item of orderItems) {
        await pool.execute(
          'INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (?, ?, ?, ?)',
          [orderId, item.product_id, item.quantity, item.price]
        );
      }
      
      totalOrders++;
    }
  }
  
  console.log(`✅ Added ${totalOrders} orders with items`);
}

async function populateTestData() {
  try {
    console.log('🚀 Starting test data population...');
    
    await populateProducts();
    await populateProductTrends();
    await populateVisitorLogs();
    await populateOrders();
    
    console.log('🎉 Test data population completed successfully!');
    
    // Display summary
    const [productCount] = await pool.execute('SELECT COUNT(*) as count FROM products');
    const [trendsCount] = await pool.execute('SELECT COUNT(*) as count FROM product_trends');
    const [visitorCount] = await pool.execute('SELECT COUNT(*) as count FROM visitor_logs');
    const [orderCount] = await pool.execute('SELECT COUNT(*) as count FROM orders');
    
    console.log('\n📊 Data Summary:');
    console.log(`   Products: ${productCount[0].count}`);
    console.log(`   Product Trends: ${trendsCount[0].count}`);
    console.log(`   Visitor Logs: ${visitorCount[0].count}`);
    console.log(`   Orders: ${orderCount[0].count}`);
    
  } catch (error) {
    console.error('❌ Error populating test data:', error.message);
    process.exit(1);
  } finally {
    await pool.end();
  }
}

populateTestData();

// ===== middleware/analytics.js =====
const { pool } = require('../config/database');

// Middleware to track product views
async function trackProductView(req, res, next) {
  try {
    const productId = req.params.id;
    
    if (productId) {
      // Update product trends
      await pool.execute(`
        INSERT INTO product_trends (product_id, views, purchases, revenue, date)
        VALUES (?, 1, 0, 0, CURDATE())
        ON DUPLICATE KEY UPDATE views = views + 1
      `, [productId]);
    }
    
    next();
  } catch (error) {
    console.error('Error tracking product view:', error);
    next(); // Continue even if tracking fails
  }
}

// Middleware to calculate conversion rates
async function updateConversionRates() {
  try {
    await pool.execute(`
      UPDATE product_trends 
      SET conversion_rate = CASE 
        WHEN views > 0 THEN (purchases / views) * 100 
        ELSE 0 
      END
      WHERE date = CURDATE()
    `);
  } catch (error) {
    console.error('Error updating conversion rates:', error);
  }
}

module.exports = {
  trackProductView,
  updateConversionRates
};

// ===== utils/helpers.js =====
const generateDateRange = (startDate, endDate, bucketSize = 'day') => {
  const start = new Date(startDate);
  const end = new Date(endDate);
  const dates = [];
  
  while (start <= end) {
    dates.push(new Date(start));
    
    switch (bucketSize) {
      case 'week':
        start.setDate(start.getDate() + 7);
        break;
      case 'month':
        start.setMonth(start.getMonth() + 1);
        break;
      default: // day
        start.setDate(start.getDate() + 1);
    }
  }
  
  return dates;
};

const formatCurrency = (amount) => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD'
  }).format(amount);
};

const calculatePercentageChange = (current, previous) => {
  if (previous === 0) return current > 0 ? 100 : 0;
  return ((current - previous) / previous) * 100;
};

module.exports = {
  generateDateRange,
  formatCurrency,
  calculatePercentageChange
};

// ===== public/dashboard.html =====
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E-commerce Analytics Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .controls {
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            align-items: end;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }
        
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .card {
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .card h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.25rem;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #667eea;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 20px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-style: italic;
        }
        
        .error {
            background: #fee;
            border: 1px solid #fcc;
            color: #c66;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📊 E-commerce Analytics Dashboard</h1>
            <p>Real-time insights into your product performance and visitor behavior</p>
        </div>
        
        <div class="controls">
            <div class="controls-grid">
                <div class="form-group">
                    <label for="startDate">Start Date:</label>
                    <input type="date" id="startDate" />
                </div>
                <div class="form-group">
                    <label for="endDate">End Date:</label>
                    <input type="date" id="endDate" />
                </div>
                <div class="form-group">
                    <label for="bucketSize">Time Period:</label>
                    <select id="bucketSize">
                        <option value="day">Daily</option>
                        <option value="week">Weekly</option>
                        <option value="month">Monthly</option>
                    </select>
                </div>
                <div class="form-group">
                    <button class="btn" onclick="loadDashboard()">Update Dashboard</button>
                </div>
            </div>
        </div>
        
        <div class="dashboard-grid">
            <div class="card">
                <h3>📈 Product Performance</h3>
                <div id="productMetrics" class="loading">Loading...</div>
                <div class="chart-container">
                    <canvas id="productChart"></canvas>
                </div>
            </div>
            
            <div class="card">
                <h3>👥 Visitor Analytics</h3>
                <div id="visitorMetrics" class="loading">Loading...</div>
                <div class="chart-container">
                    <canvas id="visitorChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h3>🏆 Top Products by Revenue</h3>
            <div id="topProducts" class="loading">Loading...</div>
        </div>
    </div>

    <script>
        let productChart, visitorChart;
        
        // Initialize date inputs with default values
        document.addEventListener('DOMContentLoaded', function() {
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(endDate.getDate() - 30);
            
            document.getElementById('endDate').value = endDate.toISOString().split('T')[0];
            document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
            
            loadDashboard();
        });
        
        async function loadDashboard() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            const bucketSize = document.getElementById('bucketSize').value;
            
            if (!startDate || !endDate) {
                alert('Please select both start and end dates');
                return;
            }
            
            try {
                await Promise.all([
                    loadProductData(startDate, endDate, bucketSize),
                    loadVisitorData(startDate, endDate, bucketSize),
                    loadTopProducts(startDate, endDate)
                ]);
            } catch (error) {
                console.error('Error loading dashboard:', error);
                showError('Failed to load dashboard data. Please try again.');
            }
        }
        
        async function loadProductData(startDate, endDate, bucketSize) {
            try {
                const response = await fetch(`/api/dashboard/products?startDate=${startDate}&endDate=${endDate}&bucketSize=${bucketSize}`);
                const data = await response.json();
                
                if (data.success) {
                    displayProductMetrics(data.data.summary);
                    updateProductChart(data.data.buckets, bucketSize);
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                document.getElementById('productMetrics').innerHTML = '<div class="error">Error loading product data</div>';
                throw error;
            }
        }
        
        async function loadVisitorData(startDate, endDate, bucketSize) {
            try {
                const response = await fetch(`/api/dashboard/visitors?startDate=${startDate}&endDate=${endDate}&bucketSize=${bucketSize}`);
                const data = await response.json();
                
                if (data.success) {
                    displayVisitorMetrics(data.data.summary);
                    updateVisitorChart(data.data.buckets, bucketSize);
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                document.getElementById('visitorMetrics').innerHTML = '<div class="error">Error loading visitor data</div>';
                throw error;
            }
        }
        
        async function loadTopProducts(startDate, endDate) {
            try {
                const response = await fetch(`/api/dashboard/top-products?startDate=${startDate}&endDate=${endDate}&limit=5`);
                const data = await response.json();
                
                if (data.success) {
                    displayTopProducts(data.data.topProducts);
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                document.getElementById('topProducts').innerHTML = '<div class="error">Error loading top products</div>';
                throw error;
            }
        }
        
        function displayProductMetrics(summary) {
            const html = `
                <div class="metric">
                    <span>Total Revenue:</span>
                    <span class="metric-value">${summary.totalRevenue.toLocaleString()}</span>
                </div>
                <div class="metric">
                    <span>Total Views:</span>
                    <span class="metric-value">${summary.totalViews.toLocaleString()}</span>
                </div>
                <div class="metric">
                    <span>Total Purchases:</span>
                    <span class="metric-value">${summary.totalPurchases.toLocaleString()}</span>
                </div>
                <div class="metric">
                    <span>Conversion Rate:</span>
                    <span class="metric-value">${summary.overallConversionRate}%</span>
                </div>
            `;
            document.getElementById('productMetrics').innerHTML = html;
        }
        
        function displayVisitorMetrics(summary) {
            const html = `
                <div class="metric">
                    <span>Total Visits:</span>
                    <span class="metric-value">${summary.totalVisits.toLocaleString()}</span>
                </div>
                <div class="metric">
                    <span>Unique Visitors:</span>
                    <span class="metric-value">${summary.totalUniqueVisitors.toLocaleString()}</span>
                </div>
                <div class="metric">
                    <span>Avg. Duration:</span>
                    <span class="metric-value">${Math.round(summary.avgVisitDuration)}s</span>
                </div>
            `;
            document.getElementById('visitorMetrics').innerHTML = html;
        }
        
        function displayTopProducts(products) {
            const html = products.map((product, index) => `
                <div class="metric">
                    <span>${index + 1}. ${product.product_name || `Product ${product.product_id}`}</span>
                    <span class="metric-value">${product.total_revenue.toLocaleString()}</span>
                </div>
            `).join('');
            document.getElementById('topProducts').innerHTML = html || '<p>No data available</p>';
        }
        
        function updateProductChart(buckets, bucketSize) {
            const ctx = document.getElementById('productChart').getContext('2d');
            
            if (productChart) {
                productChart.destroy();
            }
            
            const labels = buckets.map(bucket => {
                if (bucketSize === 'day') {
                    return new Date(bucket.startDate).toLocaleDateString();
                } else if (bucketSize === 'week') {
                    return `Week of ${new Date(bucket.startDate).toLocaleDateString()}`;
                } else {
                    return new Date(bucket.startDate).toLocaleDateString('en-US', { year: 'numeric', month: 'long' });
                }
            });
            
            productChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Revenue ($)',
                            data: buckets.map(b => b.total_revenue),
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            yAxisID: 'y'
                        },
                        {
                            label: 'Views',
                            data: buckets.map(b => b.total_views),
                            borderColor: '#f093fb',
                            backgroundColor: 'rgba(240, 147, 251, 0.1)',
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: 'Revenue ($)' }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: { display: true, text: 'Views' },
                            grid: { drawOnChartArea: false }
                        }
                    }
                }
            });
        }
        
        function updateVisitorChart(buckets, bucketSize) {
            const ctx = document.getElementById('visitorChart').getContext('2d');
            
            if (visitorChart) {
                visitorChart.destroy();
            }
            
            const labels = buckets.map(bucket => {
                if (bucketSize === 'day') {
                    return new Date(bucket.startDate).toLocaleDateString();
                } else if (bucketSize === 'week') {
                    return `Week of ${new Date(bucket.startDate).toLocaleDateString()}`;
                } else {
                    return new Date(bucket.startDate).toLocaleDateString('en-US', { year: 'numeric', month: 'long' });
                }
            });
            
            visitorChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Total Visits',
                            data: buckets.map(b => b.total_visits),
                            backgroundColor: 'rgba(102, 126, 234, 0.8)'
                        },
                        {
                            label: 'Unique Visitors',
                            data: buckets.map(b => b.unique_visitors),
                            backgroundColor: 'rgba(240, 147, 251, 0.8)'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Count' }
                        }
                    }
                }
            });
        }
        
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.querySelector('.container').insertBefore(errorDiv, document.querySelector('.dashboard-grid'));
            
            setTimeout(() => {
                errorDiv.remove();
            }, 5000);
        }
    </script>
</body>
</html>

// ===== README.md =====
# E-commerce Evaluation App

A complete Node.js e-commerce application with advanced analytics dashboard featuring product trends tracking and visitor analytics with bucket-based filtering.

## 🚀 Features

### Core E-commerce Functionality
- **Product Management**: Full CRUD operations for products
- **Order Processing**: Complete order management system
- **Customer Tracking**: Visitor behavior analytics

### Analytics Dashboard
- **Product Trends**: Views, purchases, revenue tracking
- **Visitor Analytics**: Session tracking, duration, actions
- **Bucket-based Filtering**: Day, week, month aggregations
- **Date Range Support**: Flexible time period analysis
- **Real-time Metrics
